----------------------------------------------------------------------------------------------------------------------------------------------------------------

	Para evitar ExceptionsInitializerError/InaccessibleObjectException
	inserir o argumento na JVM:
	--add-opens java.base/java.lang=ALL-UNNAMED

----------------------------------------------------------------------------------------------------------------------------------------------------------------

	Um teste necessita de:
		* Um cenário, onde tudo que necessitamos é inicializado.
		* A execução da ação a ser testada.
		* A validação após a ação ser executada.
		
----------------------------------------------------------------------------------------------------------------------------------------------------------------

	Princípios de um teste unitário (FIRST):
	
		Fast - Rápido de ser criado e executado, pois a bateria deve ser executada a cada alteração realizada no código.
		Independent - Execuções de outros testes, ou altereação de ordem de execução não devem influenciar.
		Repeatable - Mesmo sendo executado várias vezes deve entregar os valores esperados.
		Self-Verifying - Auto verificável.
		Timely - Utilizado na oportunidade correta.
		
----------------------------------------------------------------------------------------------------------------------------------------------------------------
	
	Padrões xUnit:
	
		Test Runner - Quem executa o teste e coleta os resultados.
		Test Fixture/Context - Pré condições necessárias aos testes.
		Test Suites - Elenca os testes que devem ser executados.
		Test Result Formatter - Padroniza os resultados dos testes.
		Assertions - Verifica o comportamento ou estado do que está sendo testado. 
		
----------------------------------------------------------------------------------------------------------------------------------------------------------------

	Uma asserção recebe o valor esperado e o valor atual, nesta ordem.
	
	Um teste unitário deve executar uma única asserção.
	
	O I do FIRST também significa isolado.
	
	Desta maneira as falhas ficam muito mais rastreáveis.
	
	Quando, em um teste com mais de uma asserção, ocorre um erro em uma delas, as próximas deixam de ser verificadas(estando com ou sem erros).
	
	Porém, quando é percebido que um mesmo cenário e uma mesma ação estão se repetindo em vários testes, vale mais a pena testar com mais de uma asserção.
	
	Um exemplo disso são testes que checam atributos de um objeto após uma ação.
	
	Neste caso, há o ganho de repetir menos códigos, mas a perda de rastreabilidade.
	
	
	>>>>>>> OBS <<<<<<<:
	
	Podemos utilizar o ErrorCollector em casos de mais de uma asserção em um mesmo teste, e mesmo que ocorram erros, 
	as demais asserções realizadas com a instância de ErrorCollector serão executadas e assim a rastreabilidade se mantém.
	
	assertThat e outras parecidas recebem os argumentos na ordem inversa as asserções comuns.
	
	assertThat(<realidade>, <expectativa>);
	
----------------------------------------------------------------------------------------------------------------------------------------------------------------

	Quando um teste possuí algum método dentro dele que lança uma exceção para cima, não devemos colocá-lo em um try/catch e dar um Assert.fail(<mensagem>) no finally.
	
	Se a exceção esperada é genérica demais, devemos colocá-la em um try/catch e verificar se a mensagem da exceção é igual a mensagem que esperávamos.
	
	Caso a exceção esperada seja específica	podemos lançar a exceção novamente para cima, pois neste ambiente de teste o Junit irá gerenciar a exceção.
	Assim evitamos falsos positivos.
	
	Clicando em cima da falha ou exceção gerada em um teste, podemos debugar o mesmo.
	
	Falhas são geradas a partir de asserções que não possuem a expectativa de resultado como esperado.
	
	Exceções são erros tratados ou não.
	
	Cores:
	
		Azul - Exceção
		Vermelho - Falha
		Azul - Passou

----------------------------------------------------------------------------------------------------------------------------------------------------------------

	Sempre que for realizado um teste, realizar logo em seguida um teste com o cenário contrário é bom para verificar se realmente tudo está saindo
	como o esperado.
	
----------------------------------------------------------------------------------------------------------------------------------------------------------------
	
	O JUnit re-inicializa todos atributos da classe a cada execução de testes, a não ser que o atributo seja estático.
	Desta maneira, temos certeza que todos testes iniciam do mesmo ponto de partida, e que as alterações nos atributos não irão se manter
	em outros testes.
	Assim, um teste não impactará nos demais.
	
----------------------------------------------------------------------------------------------------------------------------------------------------------------

	Método tradicional: Código -> Teste -> Refatoração(se necessário).
	TDD: Teste -> Código(o mínimo de código possível para passar no teste) -> Refatoração.
	
----------------------------------------------------------------------------------------------------------------------------------------------------------------
	
	Quando precisamos checar se um teste possui um requisito para só assim ser executado, podemos utilizar a classe Assume.
	Assim, o teste só será executado se a condição externa estiver sendo satisfeita, e não irá atrapalhar a bateria marcando o teste como falho.
	Podemos também ignorar o teste utilizando @Ignore.
	
----------------------------------------------------------------------------------------------------------------------------------------------------------------
	
	Existem casos em que os testes seguem a mesma estrutura, alterando apenas a massa de dados de entrada(na etapa de cenário), e a massa de dados de saída(na etapa de verificação).
	Podemos fazer uma análise de classes de equivalência, onde é pego um exemplo que represente cada uma destas classes semelhantes.
	Se o teste em cima deste representante passar, a probabilidade de que este teste funciona para os seus semelhantes é grande.
	Deste modo, podemos reduzir muito o código de testes.
	O nome desta técnica é data driven test(testes orientados a dados).
	
----------------------------------------------------------------------------------------------------------------------------------------------------------------

	Uma suíte de testes é uma coleção de casos de teste ou specs destinados a testar um programa para verificar 
	um determinado comportamento. 
	As suítes de teste são usualmente divididas de acordo com as funcionalidades do sistema ou com o tipo 
	de teste executado.

	Podemos rodar todos testes de um pacote apenas, assim não precisamos de suítes.
	Basta clicar com o botão direito no pacote e rodar como teste Junit.
	
	OBS: Se houver uma suíte dentro do pacote executado, ela irá executar normalmente, podendo ocorrer duplicações da execução de testes.
	
----------------------------------------------------------------------------------------------------------------------------------------------------------------
	
	Utilizando o padrão Builder, caso uma entidade tenha um atributo removido ou adicionado no construtor, os testes não serão impactados, apenas o Builder terá
	que ser atualizado.

----------------------------------------------------------------------------------------------------------------------------------------------------------------
	
	Coberturas de teste não indicam que o código está bem testado.
	Um teste que passe por determinadas linhas indicaria uma cobertura, mas os cenários possíveis podem não estar sendo explorados.
	Por este motivo, os testes devem passar 100%, e a cobertura de código pode ficar entre 80% que é aceitável.
	O mais importante nas coberturas, é analisar as linhas vermelhas e as condições que não foram exploradas todas possibilidades de caminho.

----------------------------------------------------------------------------------------------------------------------------------------------------------------

	Um teste unitário não deve possuir dependências externas, como acesso ao banco, rede, arquivos ou qualquer outra entidade externa ao código que desejamos testar.
	
	Em relação ao Fast:
		Estas dependências irão demorar alguns segundos para serem carregadas(o que para testes unitários são uma eternidade).
	
	Em relação ao Independent: 
		Podem ocorrer falha de rede, banco de dados não configurado, falta de massa de dados necessária para determinado cenário.
		Um teste unitário deve ser isolado, se um teste falha, logo após devemos saber o motivo.
		Nosso objetivo é saber o motivo da falha no nosso código, e falhas nas dependências externas comprometem esse objetivo.
	
	Em relação ao Repeatable:
		Devemos garantir que o ambiente todo esteja a nossa disposição.
		Não podemos garantir isso em relação as dependências externas.
	
	Em relação ao Timely:
		se precisarmos aguardar as dependências externas estarem configuradas, não iremos conseguir realizar os testes em desenvolvimento.
		Logo o momento oportuno para realizar o teste já terá passado.
		
	Por conta de dependências externas, os resultados obtidos nos testes podem variar mesmo que não alteremos o código.
	Tudo isso porque os resultados irão ter dependência da disponibilidade das dependências externas.

----------------------------------------------------------------------------------------------------------------------------------------------------------------
	
	Se em um método for utilizado um Matcher em um dos parâmetros, precisaremos utilizar Matchers em todos os outros parâmetros também.

	Quando se utiliza um método de um mock, e não é definido o que ele deve retornar, será retornado o valor padrão de acordo com o tipo do retorno do método.
	
	Em caso de classes: null
	Em caso de int: 0
	Em caso de double: 0.0
	
	E assim por diante...
	
	O retorno de um método de um mock só estará de acordo se os parâmetros do método na ação forem os mesmos que
	definimos no when(...).
	
	Caso contrário, o método retornará o valor padrão
	
	###################################################

	Exemplo 01:
	
	when(calculadora.somar(5, 5)).thenReturn(99);
	System.out.println(calculadora.somar(5, 5)); // 99
	
	###################################################
	
	Exemplo 02:
	
	when(calculadora.somar(5, 5)).thenReturn(99);
	System.out.println(calculadora.somar(5, 2)); // 0 -> Valor padrão
	
	###################################################
	
	Quando definimos mais de um when com os mesmos parâmetros, mas com retornos diferentes, 
	o retorno definido no último when irá sobrepor os demais.
	
	when(calculadora.somar(5, 5)).thenReturn(99);
	when(calculadora.somar(5, 5)).thenReturn(222); // Sobrepondo os parâmetros.
	
	System.out.println(calculadora.somar(5, 5)); // 222
	
	when(calculadora.somar(Mockito.anyInt(), Mockito.anyInt())).thenReturn(68985); // Sobrepondo os parâmetros.
	
	System.out.println(calculadora.somar(5, 5)); // 68985
	
----------------------------------------------------------------------------------------------------------------------------------------------------------------
	
	@Spy vs @Mock
		
	Spy não pode ser utilizado em interfaces, pois quando um @Spy não possui uma instrução de retorno para determinados parâmetros, ele tentará executar o método
	da implementação da classe.
	
	Quando chamamos o when(...) e definimos uma expectativa para um método de um Spy, neste momento o método concreto da classe é executado.
	
	Devemos utilizar Mockito.doReturn(<valor de retorno>).when(spy).somar(<x>, <y>), assim não executamos o método concreto ao criar a expectativa.
	
	Quando um Spy não entende o que deve retornar para determinados parâmetros, ele irá executar o método concreto da classe.
	Quando entende, ele não executa o método concreto.
	
	Um mock só passa pelo corpo do método concreto se chamarmos .thenCallRealMethod() e ele souber o que deve retornar no uso de determinados parâmetros.
	
----------------------------------------------------------------------------------------------------------------------------------------------------------------
